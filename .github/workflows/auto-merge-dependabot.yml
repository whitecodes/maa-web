name: Auto-merge Dependabot PRs

on:
  workflow_run:
    workflows: ["Dependabot Placeholder Check"]
    types: [completed]

# Permissions for workflow_run event
permissions:
  contents: write
  pull-requests: write
  checks: read
  actions: read

jobs:
  auto-merge:
    name: Auto-merge Dependabot PR
    runs-on: ubuntu-latest

    # Only run if placeholder workflow succeeded
    if: github.event.workflow_run.conclusion == 'success'
    
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Get PR details from workflow_run
        id: pr-details
        uses: actions/github-script@v7
        with:
          script: |
            console.log('üîç Getting PR details from workflow_run event...');
            console.log('Workflow run:', context.payload.workflow_run);

            // Get the PR associated with the workflow run
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`,
              state: 'open'
            });

            if (prs.length === 0) {
              core.setFailed('No open PR found for this workflow run');
              return;
            }

            const pr = prs[0];
            console.log(`PR Number: ${pr.number}`);
            console.log(`PR Title: ${pr.title}`);
            console.log(`PR Author: ${pr.user.login}`);
            console.log(`PR Base: ${pr.base.ref}`);
            console.log(`PR Head: ${pr.head.ref}`);

            // Verify this is a Dependabot PR
            if (pr.user.login !== 'dependabot[bot]') {
              core.setFailed(`Not a Dependabot PR. Author: ${pr.user.login}`);
              return;
            }

            return {
              number: pr.number,
              title: pr.title,
              author: pr.user.login,
              base: pr.base.ref,
              head: pr.head.ref,
              node_id: pr.node_id,
              sha: pr.head.sha
            };

      - name: Determine update type
        id: update-type
        run: |
          PR_TITLE="${{ fromJson(steps.pr-details.outputs.result).title }}"
          echo "PR Title: $PR_TITLE"
          
          # Check for major version updates (should not auto-merge)
          if echo "$PR_TITLE" | grep -E "(major|breaking|BREAKING)" -i; then
            echo "update_type=major" >> $GITHUB_OUTPUT
            echo "auto_merge=false" >> $GITHUB_OUTPUT
            echo "reason=Major version update detected" >> $GITHUB_OUTPUT
          # Check for minor/patch updates (safe to auto-merge)
          elif echo "$PR_TITLE" | grep -E "(minor|patch|bump|update)" -i; then
            echo "update_type=minor_or_patch" >> $GITHUB_OUTPUT
            echo "auto_merge=true" >> $GITHUB_OUTPUT
            echo "reason=Minor or patch update detected" >> $GITHUB_OUTPUT
          # Check for security updates (should auto-merge)
          elif echo "$PR_TITLE" | grep -E "(security|vulnerability|CVE)" -i; then
            echo "update_type=security" >> $GITHUB_OUTPUT
            echo "auto_merge=true" >> $GITHUB_OUTPUT
            echo "reason=Security update detected" >> $GITHUB_OUTPUT
          # Default: check if it looks like a standard dependency update
          elif echo "$PR_TITLE" | grep -E "^(build\(deps\)|chore\(deps\))" -i; then
            echo "update_type=dependency" >> $GITHUB_OUTPUT
            echo "auto_merge=true" >> $GITHUB_OUTPUT
            echo "reason=Standard dependency update" >> $GITHUB_OUTPUT
          else
            echo "update_type=unknown" >> $GITHUB_OUTPUT
            echo "auto_merge=false" >> $GITHUB_OUTPUT
            echo "reason=Unable to determine update type" >> $GITHUB_OUTPUT
          fi

      - name: Log decision
        run: |
          echo "üîç Update Type: ${{ steps.update-type.outputs.update_type }}"
          echo "ü§ñ Auto-merge: ${{ steps.update-type.outputs.auto_merge }}"
          echo "üìù Reason: ${{ steps.update-type.outputs.reason }}"

      - name: Wait for CI checks
        if: steps.update-type.outputs.auto_merge == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const maxWaitTime = 30 * 60 * 1000; // 30 minutes
            const pollInterval = 30 * 1000; // 30 seconds
            const startTime = Date.now();
            
            console.log('‚è≥ Waiting for CI checks to complete...');
            
            while (Date.now() - startTime < maxWaitTime) {
              const prDetails = ${{ steps.pr-details.outputs.result }};
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: prDetails.sha
              });

              const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: prDetails.sha
              });
              
              // Get all check runs and statuses
              const allChecks = [
                ...checks.check_runs.map(check => ({
                  name: check.name,
                  status: check.status,
                  conclusion: check.conclusion
                })),
                ...statuses.map(status => ({
                  name: status.context,
                  status: status.state === 'pending' ? 'in_progress' : 'completed',
                  conclusion: status.state
                }))
              ];
              
              console.log('üìä Current check status:');
              allChecks.forEach(check => {
                console.log(`  - ${check.name}: ${check.status} (${check.conclusion || 'N/A'})`);
              });
              
              // Filter out this workflow's checks to avoid circular dependency
              const currentWorkflowName = 'Auto-merge Dependabot PRs';
              const relevantChecks = allChecks.filter(check => {
                const checkName = check.name.toLowerCase();
                const isCurrentWorkflow = checkName.includes('auto-merge') ||
                                        checkName.includes(currentWorkflowName.toLowerCase()) ||
                                        check.name === currentWorkflowName;

                if (isCurrentWorkflow) {
                  console.log(`üîÑ Filtering out self-check: ${check.name}`);
                  return false;
                }
                return true;
              });
              
              if (relevantChecks.length === 0) {
                console.log('‚ö†Ô∏è No CI checks found, proceeding with merge');
                break;
              }
              
              const pendingChecks = relevantChecks.filter(check => 
                check.status === 'in_progress' || check.status === 'queued' || check.conclusion === 'pending'
              );
              
              const failedChecks = relevantChecks.filter(check => 
                check.conclusion === 'failure' || check.conclusion === 'error' || check.conclusion === 'cancelled'
              );
              
              if (failedChecks.length > 0) {
                console.log('‚ùå CI checks failed:');
                failedChecks.forEach(check => {
                  console.log(`  - ${check.name}: ${check.conclusion}`);
                });
                core.setFailed('CI checks failed, cannot auto-merge');
                return;
              }
              
              if (pendingChecks.length === 0) {
                console.log('‚úÖ All CI checks passed!');
                break;
              }
              
              console.log(`‚è≥ Waiting for ${pendingChecks.length} checks to complete...`);
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            if (Date.now() - startTime >= maxWaitTime) {
              core.setFailed('Timeout waiting for CI checks to complete');
            }

      - name: Enable auto-merge
        if: steps.update-type.outputs.auto_merge == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('üöÄ Enabling auto-merge for Dependabot PR...');

            try {
              // Get PR details from previous step
              const prDetails = ${{ steps.pr-details.outputs.result }};

              // First check if auto-merge is already enabled
              const prQuery = `
                query GetPR($owner: String!, $name: String!, $number: Int!) {
                  repository(owner: $owner, name: $name) {
                    pullRequest(number: $number) {
                      autoMergeRequest {
                        enabledAt
                        mergeMethod
                      }
                      mergeable
                      mergeStateStatus
                    }
                  }
                }
              `;

              const prInfo = await github.graphql(prQuery, {
                owner: context.repo.owner,
                name: context.repo.repo,
                number: prDetails.number
              });

              console.log('üìä PR Info:', JSON.stringify(prInfo, null, 2));

              if (prInfo.repository.pullRequest.autoMergeRequest) {
                console.log('‚úÖ Auto-merge is already enabled for this PR');
                console.log(`Enabled at: ${prInfo.repository.pullRequest.autoMergeRequest.enabledAt}`);
                console.log(`Merge method: ${prInfo.repository.pullRequest.autoMergeRequest.mergeMethod}`);
              } else {
                console.log('üöÄ Enabling auto-merge for Dependabot PR...');

                // Use GraphQL API to enable auto-merge
                const mutation = `
                  mutation EnableAutoMerge($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                    enablePullRequestAutoMerge(input: {
                      pullRequestId: $pullRequestId,
                      mergeMethod: $mergeMethod
                    }) {
                      pullRequest {
                        autoMergeRequest {
                          enabledAt
                          mergeMethod
                        }
                      }
                    }
                  }
                `;

                const result = await github.graphql(mutation, {
                  pullRequestId: prDetails.node_id,
                  mergeMethod: 'SQUASH'
                });

                console.log('‚úÖ Auto-merge enabled successfully!');
                console.log('üìä Result:', JSON.stringify(result, null, 2));
              }

              // Add a comment to the PR
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prDetails.number,
                body: `ü§ñ **Auto-merge enabled**\n\n` +
                      `This Dependabot PR has been automatically approved for merging because:\n` +
                      `- ‚úÖ Author is verified as dependabot[bot]\n` +
                      `- ‚úÖ Update type: ${{ steps.update-type.outputs.update_type }}\n` +
                      `- ‚úÖ All CI checks passed\n\n` +
                      `The PR will be automatically merged when all required status checks pass.`
              });

            } catch (error) {
              console.error('‚ùå Failed to enable auto-merge:', error);
              console.error('Error details:', error.message);

              // Handle specific error cases
              if (error.message && error.message.includes('Pull request is in clean status')) {
                console.log('‚ÑπÔ∏è This error usually means:');
                console.log('  1. Auto-merge is already enabled, or');
                console.log('  2. The repository auto-merge feature is disabled, or');
                console.log('  3. Branch protection rules prevent auto-merge');

                // Try to get more info about the PR status
                try {
                  const prDetails = ${{ steps.pr-details.outputs.result }};
                  const { data: pr } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prDetails.number
                  });

                  console.log(`PR mergeable state: ${pr.mergeable_state}`);
                  console.log(`PR mergeable: ${pr.mergeable}`);

                  // Still add a comment explaining the situation
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prDetails.number,
                    body: `ü§ñ **Auto-merge attempted**\n\n` +
                          `This Dependabot PR meets the criteria for auto-merge, but auto-merge could not be enabled.\n\n` +
                          `**Possible reasons:**\n` +
                          `- Auto-merge may already be enabled\n` +
                          `- Repository auto-merge feature might be disabled\n` +
                          `- Branch protection rules may prevent auto-merge\n\n` +
                          `**PR Status:**\n` +
                          `- Mergeable state: ${pr.mergeable_state}\n` +
                          `- Mergeable: ${pr.mergeable}\n\n` +
                          `Please check the PR status and merge manually if needed.`
                  });

                  // Don't fail the workflow for this specific error
                  console.log('‚ö†Ô∏è Auto-merge could not be enabled, but this is not necessarily an error');
                  return;
                } catch (commentError) {
                  console.error('Failed to add explanatory comment:', commentError);
                }
              }

              core.setFailed(`Failed to enable auto-merge: ${error.message}`);
            }

      - name: Skip auto-merge
        if: steps.update-type.outputs.auto_merge == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('‚è≠Ô∏è Skipping auto-merge for this PR');

            const prDetails = ${{ steps.pr-details.outputs.result }};
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prDetails.number,
              body: `ü§ñ **Auto-merge skipped**\n\n` +
                    `This Dependabot PR was not automatically merged because:\n` +
                    `- üìã Reason: ${{ steps.update-type.outputs.reason }}\n` +
                    `- üîç Update type: ${{ steps.update-type.outputs.update_type }}\n\n` +
                    `Please review this PR manually before merging.`
            });
